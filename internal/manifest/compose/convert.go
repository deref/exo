package compose

import (
	"fmt"
	"io"
	"strings"

	"github.com/deref/exo/internal/manifest"
	"github.com/deref/exo/internal/providers/docker/compose"
	"github.com/deref/exo/internal/util/yamlutil"
	"github.com/goccy/go-yaml"
)

type Loader struct {
	// ProjectName is used as a prefix for the resources created by this importer.
	ProjectName string
}

func (i *Loader) Load(r io.Reader) manifest.LoadResult {
	var project compose.ProjectTemplate
	dec := yaml.NewDecoder(r)
	if err := dec.Decode(&project); err != nil {
		return manifest.LoadResult{Err: fmt.Errorf("parsing: %w", err)}
	}
	return i.convert(&project)
}

func (i *Loader) convert(project *compose.ProjectTemplate) manifest.LoadResult {
	res := manifest.LoadResult{
		Manifest: &manifest.Manifest{},
	}

	// Since containers reference networks and volumes by their docker-compose name, but the
	// Docker components will have a namespaced name, so we need to keep track of which
	// volumes/components a service references.
	networksByComposeName := map[string]string{}
	volumesByComposeName := map[string]string{}

	for originalName, volume := range project.Volumes {
		name := manifest.MangleName(originalName)
		if originalName != name {
			res = res.AddRenameWarning(originalName, name)
		}

		if volume.Name == "" {
			volume.Name = i.prefixedName(originalName, "")
		}
		volumesByComposeName[originalName] = volume.Name

		res.Manifest.Components = append(res.Manifest.Components, manifest.Component{
			Name: name,
			Type: "volume",
			Spec: yamlutil.MustMarshalString(volume),
		})
	}

	// Set up networks.
	hasDefaultNetwork := false
	for originalName, network := range project.Networks {
		if originalName == "default" {
			hasDefaultNetwork = true
		}
		name := manifest.MangleName(originalName)
		if originalName != name {
			res = res.AddRenameWarning(originalName, name)
		}

		// If a `name` key is specified in the network configuration (usually used in conjunction with `external: true`),
		// then we should honor that as the docker network name. Otherwise, we should set the name as
		// `<project_name>_<network_key>`.
		if network.Name == "" {
			network.Name = i.prefixedName(originalName, "")
		}
		networksByComposeName[originalName] = network.Name

		if network.Driver == "" {
			network.Driver = "bridge"
		}

		res.Manifest.Components = append(res.Manifest.Components, manifest.Component{
			Name: name,
			Type: "network",
			Spec: yamlutil.MustMarshalString(network),
		})
	}
	// TODO: Docker Compose only creates the default network if there is at least 1 service that does not
	// specify a network. We should do the same.
	if !hasDefaultNetwork {
		componentName := "default"
		name := i.prefixedName(componentName, "")
		networksByComposeName[componentName] = name

		res.Manifest.Components = append(res.Manifest.Components, manifest.Component{
			Name: componentName,
			Type: "network",
			Spec: yamlutil.MustMarshalString(map[string]string{
				"name":   name,
				"driver": "bridge",
			}),
		})
	}

	for originalName, service := range project.Services {
		name := manifest.MangleName(originalName)
		if originalName != name {
			res = res.AddRenameWarning(originalName, name)
		}
		component := manifest.Component{
			Name: name,
			Type: "container",
		}

		if service.ContainerName == "" {
			// The generated container name intentionally matches the container name generated by Docker Compose
			// when the scale is set at 1. When we address scaling containers, this will need to be updated to
			// use a different suffix for each container.
			service.ContainerName = i.prefixedName(originalName, "1")
		}

		if service.Labels == nil {
			service.Labels = make(compose.Dictionary)
		}
		for k := range service.Labels {
			if strings.HasPrefix(k, "com.docker.compose") {
				res.Err = fmt.Errorf("service may not specify labels with prefix \"com.docker.compose\", but %q specified %q", originalName, k)
				return res
			}
		}
		service.Labels["com.docker.compose.project"] = &i.ProjectName
		service.Labels["com.docker.compose.service"] = &originalName

		// Map the docker-compose network name to the name of the docker network that is created.
		defaultNetworkName := networksByComposeName["default"]
		if len(service.Networks) > 0 {
			mappedNetworks := make(compose.ServiceNetworksTemplate, len(service.Networks))
			for i, network := range service.Networks {
				networkName, ok := networksByComposeName[network.Network]
				if !ok {
					res.Err = fmt.Errorf("unknown network: %q", networkName)
					continue
				}
				mappedNetworks[i] = network
				component.DependsOn = append(component.DependsOn, networkName)
			}
			service.Networks = mappedNetworks
		} else {
			service.Networks = compose.ServiceNetworksTemplate{
				compose.ServiceNetworkTemplate{
					Network: defaultNetworkName,
				},
			}
			component.DependsOn = append(component.DependsOn, "default")
		}

		if len(service.Volumes) > 0 {
			for i, volumeMount := range service.Volumes {
				if volumeMount.Type != "volume" {
					continue
				}
				if volumeName, ok := volumesByComposeName[volumeMount.Source]; ok {
					originalName := volumeMount.Source
					service.Volumes[i].Source = volumeName
					component.DependsOn = append(component.DependsOn, originalName)
				}
				// If the volume was not listed under the top-level "volumes" key, then the docker engine
				// will create a new volume that will not be namespaced by the Compose project name.
			}
		}

		for _, dependency := range service.DependsOn {
			if dependency.Condition != "service_started" {
				res = res.AddUnsupportedFeatureWarning(fmt.Sprintf("service %q has condition %q", dependency.Service, dependency.Condition), "only service_started is currently supported")
			}
			component.DependsOn = append(component.DependsOn, manifest.MangleName(dependency.Service))
		}

		for idx, link := range service.Links {
			var linkService, linkAlias string
			parts := strings.Split(link, ":")
			switch len(parts) {
			case 1:
				linkService = parts[0]
				linkAlias = parts[0]
			case 2:
				linkService = parts[0]
				linkAlias = parts[1]
			default:
				res.Err = fmt.Errorf("expected SERVICE or SERVICE:ALIAS for link, but got: %q", link)
				return res
			}
			// NOTE [RESOLVING SERVICE CONTAINERS]:
			// There are several locations in a compose definition where a service may reference another service
			// by the compose name. We currently handle these situations by rewriting these locations to reference
			// a container named `<project>_<mangled_service_name>_1` with the assumption that a container will
			// be created by that name. However, this will break when the referenced service specifies a non-default
			// container name. Additionally, we may want to handle cases where a service is scaled past a single
			// container.
			// Some of these values could/should be resolved at runtime, and we should do it when we have the entire
			// project graph available.

			// See https://github.com/docker/compose/blob/v2.0.0-rc.3/compose/service.py#L836 for how compose configures
			// links.
			mangledServiceName := manifest.MangleName(linkService)
			containerName := i.prefixedName(mangledServiceName, "1")
			service.Links[idx] = fmt.Sprintf("%s:%s", containerName, linkAlias)
			component.DependsOn = append(component.DependsOn, mangledServiceName)
		}

		component.Spec = yamlutil.MustMarshalString(service)
		res.Manifest.Components = append(res.Manifest.Components, component)
	}

	return res
}

func (i *Loader) prefixedName(name string, suffix string) string {
	var out strings.Builder
	out.WriteString(i.ProjectName)
	out.WriteByte('_')
	out.WriteString(name)
	if suffix != "" {
		out.WriteByte('_')
		out.WriteString(suffix)
	}

	return out.String()
}
